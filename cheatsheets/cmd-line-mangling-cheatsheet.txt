[awk] (pattern scanning)
  cat input.txt | awk '{print $4}' [split the content using whitespace (default delimiter), return the 4th element]

cmd substitution/nesting
  diff <(head ./file1) <(head ./file2) [nested cmds]

[cut] (remove portions of a file)
  cut -d '/' -f 1 [uses '/' as the delimiter, extracts field 1]


[diff]
  diff file1 file2

	nested diff
	diff <(head ./file1) <(head ./file2)

[head] (First xx lines (default is 10))
  head -n xx tgt.txt

[grep]
  grep -e any -e of -e these /in/this/file
	-w ["whole word" matching only]
  grep -w string /in/this/file

output redirection
  cat input.txt > output.txt [overwrites]
  cat input.txt >> output.txt [appends]
  cat input.txt 2> errors.txt [redirect stderr and overwrite]
  cat input.txt &>> log.txt [redirect stdout and stderr, and append]
  wc -l < input.txt [takes input.txt as input, useful for reordering parsing flows]

[sort]
  cat raw.txt | sort
    -n numerical sort (iw, 2 > 11)
    -u [unique rows]
    -V natural sort (ie, 2 < 11)
    by default:
    By default, the GNU sort command applies lexicographic (alphabetical) order based on the current locale's collating rules. This means:
    It sorts lines character by character, following the order defined by the locale.
    If no sorting keys are specified, it considers the entire line as the sorting key.
    Numbers are treated as strings, so "11" comes before "2" (because "1" is smaller than "2" in ASCII order)

[sed] ("stream editor")
  cat input.txt | sed 's/,$//' [this removes trailing commas on every line. idfk...]

[tee] (splitting stdout)
  cmd | tee file1 | file2

[tr] (translate/delete chars)
  cat input.txt | tr 'a' 'A' [replaces a with A]
  cat input.txt | tr '\n' ',' [replaces newlines with commas]

[wc] (count lines in file)
  cat raw.txt | wc -l
  PS: Get-Content tgt.txt | Measure-Object -Line

[watch] (live view)
  watch -n 0.5 cat /dev/random

File getters
  Invoke-NinjaCopy
  robocopy
  RawCopy